{
  "hash": "79025dae1f6efd9d029d108bb5da036f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\ntitle: Demystyfing Docker \n---\n\n## Learning objectives\n\n- Decide whether a container is the right tool for a given job.\n- Download and run pre-built Docker images.\n- Describe the stages of the Docker container lifecycle.\n- Build simple Dockerfiles for your own projects.\n\n## Why docker matters for data science \n\n- Docker creates standardized environments that are:\n\n  1. Reproducible\n\n  2. Portable \n\n  3. Collaborative \n  \n  4. Scalable\n\n![](images/06_docker-logo.png){.absolute width=480 height=270 left=500px top=200px fig-alt=\"The Docker logo, a whale with shipping containers on its back\"}\n\n::: aside\nSee [An Introduction to Docker for R Users](https://colinfay.me/docker-r-reproducibility/) for a guide on reproducibility with Docker for R users\n:::\n\n::: {.notes}\n\n- Docker allows us to set up infrastructure as code\n\n- Docker enhances reproducibility by creating a reproducible environment all the way down to the operating system - important for highly regulated industries\n\n- Docker allows you to develop your project using an image that may more closely match the production environment - important for Shiny apps and APIs\n\n:::\n\n## What is Docker? \n\n- An open-source tool for building, sharing, and running software\n\n![](images/06_docker-lifecycle.png){fig-align=\"center\" width=50% height=50% fig-alt=\"The Docker lifecycle and commands, showing that a Dockerfile produces a Docker Image, which leads to a Docker Container\"}\n\n::: {.notes}\n\n- Requires a Linux operating system or the Windows Subsystem for Linux (WSL)\n\n- Windows and macOS users download [Docker Desktop](https://www.docker.com/products/docker-desktop/), which comes with a Linux VM. Linux users are recommended to install the [Docker Engine](https://docs.docker.com/engine/install/) directly.\n\n- Three terms to be familiar with are DockerFile, Docker Image, and Container Instances. \n\n- Note that the names *container* and *instance* are often used interchangeably\n\n:::\n\n## Specify your environment via a `Dockerfile`\n\n- Dockerfiles build Docker images\n\n- Dockerfiles are plain text files using `FROM`, `RUN`, `COPY`, and `CMD` commands \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nFROM ubuntu:latest # <1>                \nCOPY my-data.csv /data/data.csv # <2>\nRUN [\"head\", \"/data/data.csv\"] # <3>\n```\n:::\n\n1. Declare the base image\n2. Copy `data.csv` from the host's working directory to the container's data directory\n3. Print the first few rows of `data.csv` \n\n::: {.notes}\n\n- Creating your own Dockerfile is optional - many standard Docker images exist on Dockerhub (e.g. [`rocker/tidyverse`]())  \n\n- Dockerfiles build images and also *pull* existing images\n\n:::\n\n## Docker images are a snapshot of your environment\n\n- Docker images contain the bundled software (e.g. OS, data, packages)\n\n- Docker images can be shared with others via [Docker hub](https://hub.docker.com/)\n\n- Docker images can, in theory, be a standalone project\n\n::: {.notes}\n\n- Other container registries exist (e.g. [Azure Container Registry](https://azure.microsoft.com/en-us/products/container-registry/?msockid=16f9494b817a63e60f275f7a80ce623d))\n\n:::\n\n## Containers are an ephemeral instance of a Docker Image\n\n- By default, changes made to containers are lost on shutdown\n\n- Data can be preserved from instance to instance of the same container using mounted volumes\n\n- Containers are a process that executes the layers of your Dockerfile  \n\n## Meeting Videos {-}\n\n### Cohort 1 {-}\n\n<iframe src=\"https://www.youtube.com/embed/gzJ3eT6tcog\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n<iframe src=\"https://www.youtube.com/embed/CHbaTCo4gQk\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n",
    "supporting": [
      "06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}